fn map_rules<'a>(rules: &'a [Rule]) -> HashMap<&'a str, &'a Vec<Range>> {
    let mut map = HashMap::new();
    for rule in rules {
        map.insert(rule.id, &rule.ranges);
    }
    map
}

fn find_field<'a>(column: Vec<u32>, rules: &'a [Rule]) -> Vec<&'a str> {
    let mut result = Vec::new();
    for rule in rules {
        let mut valid = true;
        for element in &column {
            let mut in_either_range = false;
            for range in &rule.ranges {
                if range.in_range(&element) {
                    in_either_range = true;
                }
            }
            valid = valid && in_either_range;
        }
        if valid {
            result.push(rule.id);
        }
    }
    println!("{:?}", result);
    result
}

fn step_fields<'a>(
    valid: &'a HashSet<&Ticket>,
    rules: &'a [Rule],
) -> HashMap<&'a str, Vec<usize>> {
    let elements = valid.iter().collect::<Vec<_>>();
    let max = elements[0].len();
    let mut column = Vec::new();
    let mut map: HashMap<&str, Vec<usize>> = HashMap::new();
    for i in 0..max {
        for element in &elements {
            column.push(element[i]);
        }
        let owned_column = column.to_owned();
        let fields = find_field(owned_column, rules);
        for field in fields {
            if let Some(_) = map.get(field) {
                map.get_mut(field).unwrap().push(i);
            } else {
                map.insert(field, vec![i]);
            }
        }
        column = Vec::new();
    }
    map
}

fn assign_fields(
    rules: &[Rule],
    nearby_tickets: &[Ticket],
    valid: &HashSet<&Ticket>,
) {
    let map_init = map_rules(rules);
    let fields = step_fields(&valid, &rules);
    // println!("{:?}", fields);
}

fn invalidate<'a>(input: &'a Input) -> (u32, HashSet<&'a Ticket>) {
    let rules = &input.rules;
    let nearby_tickets = &input.nearby_tickets;

    let mut result = 0;
    let mut valid_tickets = HashSet::new();

    for ticket in nearby_tickets {
        for field in ticket {
            let mut valid = false;
            for rule in rules {
                if !valid {
                    for range in &rule.ranges {
                        if range.in_range(field) {
                            valid = true;
                            break;
                        }
                    }
                }
            }
            if valid {
                valid_tickets.insert(ticket);
            } else {
                result += field;
            }
        }
    }

    (result, valid_tickets)
}

